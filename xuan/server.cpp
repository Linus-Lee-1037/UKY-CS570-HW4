/*
 * Modified from sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <unordered_map>
#include <string>
#include <vector>
#include <set>
#include <fcntl.h>
#include <unistd.h>
#include "ssnfs.h"

const int disk_capacity = 16 * 1024 * 1024; 
const int file_capacity = 64 * 512;
const int table_capacity = 20;
const int max_files = 512;

int existing_file_count = 0;
int curr_fd = 0;

struct file_info{
	char user_name[USER_NAME_SIZE];
	char file_name[FILE_NAME_SIZE];
	int sequence_no;
	int used;
	file_info(const char uname[], const char fname[], int sq_no):sequence_no(sq_no){
		strcpy(user_name, uname);
		strcpy(file_name, fname);
	}
	file_info(){sequence_no = -1;}
};
typedef struct file_info file_info;

struct file_item{
	char user_name[USER_NAME_SIZE];
	char file_name[FILE_NAME_SIZE];
	int sequence_no;
	int used;
	int fd;
	int fptr;
	bool seek_flag;
	file_item(const char uname[], const char fname[], int sq_no, int fd_, int used_) : sequence_no(sq_no), fd(fd_), used(used_){
		fptr = 0;
		seek_flag = false;
		strcpy(user_name, uname);
		strcpy(file_name, fname);
	}
	file_item(){}
};
typedef struct file_item file_item;

struct open_file_table{
	int open_file_count;
	std::vector<file_item> items;
	open_file_table(){
		open_file_count = 0;
	}
};
typedef struct open_file_table open_file_table;

open_file_table *open_table_ptr = new open_file_table;

std::unordered_map<int, int> fd_table;

int init_disk(){
    if((access("disk.dat", F_OK) == 0) && (access("files.dat", F_OK) == 0)){
		return 1;
    }else{
        ftruncate(creat("disk.dat", 0666), disk_capacity);
		ftruncate(creat("files.dat", 0666), sizeof(file_info)*max_files);
		return 0;
    }
}

int file_exists(char *username, char *filename, int& used_size){
    file_info fi;
    int ffd = open("files.dat", O_RDONLY);
	int sq_no = -1;
    while(read(ffd, &fi, sizeof(file_info)) > 0){
        if((strcmp(username, fi.user_name) == 0) && (strcmp(filename, fi.file_name) == 0)){
            sq_no = fi.sequence_no;
			used_size = fi.used;
            break;
        }
    }
    close(ffd);
    return sq_no;
}

int get_sqno_from_fdtable(int fd){
	int sq_no = -1;
	for(auto it:fd_table){
		if(it.second == fd){
			sq_no = it.first;
			break;
		}
	}
	return sq_no;
}

/**************************************************************************************/

open_output *
open_file_1_svc(open_input *argp, struct svc_req *rqstp){
	static open_output result;
	init_disk();
	printf("(Open)In server: username recieved: %s, filename received: %s\n", argp->user_name, argp->file_name);
	char message[512];

	result.fd = -1;
	file_item *item_ptr = nullptr;
	for(int i=0; i<open_table_ptr->items.size(); i++){ // check if already opened
		item_ptr = &open_table_ptr->items[i];
		if(!strcmp(argp->user_name, item_ptr->user_name) && !strcmp(argp->file_name, item_ptr->file_name)){
			snprintf(message, 512, "Open: file '%s' already opened", argp->file_name);
			result.fd = item_ptr->fd;
			break;
		}
	}
	if(result.fd < 0){ // not in open_table
		int used_size = 0;
		int sq_no = file_exists(argp->user_name, argp->file_name, used_size);
		if(sq_no >= 0){ // file exists but not opened
			if(open_table_ptr->open_file_count < table_capacity){
				fd_table[sq_no] = curr_fd++;
				result.fd = fd_table[sq_no];
				open_table_ptr->items.push_back(file_item(argp->user_name, argp->file_name, sq_no, fd_table[sq_no], used_size));
				open_table_ptr->open_file_count++;
				snprintf(message, 512, "Existing file '%s' opened for user %s", argp->file_name, argp->user_name);
			}else{
				strcpy(message, "Open: Reached open file table capacity");
			}
		}else{
			if(open_table_ptr->open_file_count < table_capacity && existing_file_count < max_files){
				// create new file and open it
				open_table_ptr->open_file_count++;
				sq_no = existing_file_count;
				fd_table[sq_no] = curr_fd++;
				open_table_ptr->items.push_back(file_item(argp->user_name, argp->file_name, sq_no, fd_table[sq_no], 0));
				result.fd = fd_table[sq_no];
				file_info fi;
				strcpy(fi.user_name, argp->user_name);
				strcpy(fi.file_name, argp->file_name);
				fi.sequence_no = sq_no;
				fi.used = 0;
                int ffd = open("files.dat", O_WRONLY | O_APPEND);
                if(ffd == -1){
                    perror("Error opening files.dat");
                    exit(EXIT_FAILURE);
                }
				lseek(ffd, sizeof(file_info)*existing_file_count, SEEK_SET);
				existing_file_count++;
                if(write(ffd, &fi, sizeof(file_info)) == -1){
                    perror("Error writing to files.dat");
                    close(ffd);
                    exit(EXIT_FAILURE);
                }
                close(ffd);
				snprintf(message, 512, "New file '%s' created and opened for user %s", argp->file_name, argp->user_name);
			}else if(open_table_ptr->open_file_count == table_capacity){
				strcpy(message, "Open: Reached open file table capacity");
			}else{
				strcpy(message, "Open: Reached max number of files");
			}
		}
	}
	result.out_msg.out_msg_len = strlen(message) + 1;
	result.out_msg.out_msg_val = strdup(message);
	return &result;
}

close_output *
close_file_1_svc(close_input *argp, struct svc_req *rqstp){
	static close_output result;
	init_disk();
	printf("(Close)In server: username received: %s, fd received: %d\n", argp->user_name, argp->fd);
	char message[512];

	int fd = argp->fd;
	bool found = false;
	for(auto it = fd_table.begin(); it != fd_table.end(); it++){
		if(it->second == fd){
			it = fd_table.erase(it);
			found = true;
			break;
		}
	}
	if(!found) snprintf(message, 512, "Close: Invalid file descriptor");

	for(auto it = open_table_ptr->items.begin(); it != open_table_ptr->items.end(); it++){
		if(it->fd == fd){
			snprintf(message, 512, "%s closed for user %s", it->file_name, argp->user_name);
			it = open_table_ptr->items.erase(it);
			open_table_ptr->open_file_count --;
			break;
		}
	}
	result.out_msg.out_msg_len = strlen(message) + 1;
	result.out_msg.out_msg_val = strdup(message);
	return &result;
}

list_output *
list_files_1_svc(list_input *argp, struct svc_req *rqstp){
	static list_output result;
	init_disk();

	char buffer[512];
	memset(buffer, 0, 512);

	int ffd;
	file_info fi;
	ffd = open("files.dat", O_RDONLY);
	while(read(ffd, &fi, sizeof(file_info))){
		if(strcmp(argp->user_name, fi.user_name) == 0){
			strcat(buffer, " ");
			strcat(buffer, fi.file_name);
		}
	}
	close(ffd);
	printf("files: %s\n", buffer);
	int bufferSize = 512+strlen("The files are: ");
	char message[bufferSize];
    snprintf(message, bufferSize, "The files are: %s", buffer);
    result.out_msg.out_msg_len = strlen(message) + 1;
    result.out_msg.out_msg_val = strdup(message);
	return &result;
}

delete_output *
delete_file_1_svc(delete_input *argp, struct svc_req *rqstp){
	static delete_output result;
	init_disk();
	printf("(Delete)In server: username received: %s, filename received: %s\n", argp->user_name, argp->file_name);
	char message[512];

	int ffd, found;
	file_info fi;

	ffd = open("files.dat", O_RDWR);
	for(found=-1; read(ffd, &fi, sizeof(file_info))>0;){
		if(strcmp(argp->user_name, fi.user_name)==0 && strcmp(argp->file_name, fi.file_name)==0){
			found = fi.sequence_no;
			break;
		}
	}
	if(found >= 0){
		if(fd_table.find(found) != fd_table.end()){
			strcpy(message, "Delete: Not allowed to delete currently opened file");
		}else{
			existing_file_count --;
			int post_num = existing_file_count - found;
			char * f_buffer = (char *)malloc(sizeof(file_info)*post_num);
			for(int i=0; i<post_num && read(ffd, &fi, sizeof(file_info))>0; i++){
				int old_sq_no = fi.sequence_no;
				fi.sequence_no = i+found;
				auto it = fd_table.find(old_sq_no);
				if(it != fd_table.end()){
					int fd = it->second;
					fd_table.erase(it);
					fd_table[fi.sequence_no] = fd;
				}
				memcpy(f_buffer + i*sizeof(file_info), &fi, sizeof(file_info));
			}
			lseek(ffd, sizeof(file_info)*found, SEEK_SET);
			write(ffd, f_buffer, sizeof(file_info)*post_num);
			free(f_buffer);
			lseek(ffd, sizeof(file_info) * existing_file_count, SEEK_SET);
			ftruncate(ffd, sizeof(file_info) * existing_file_count);
			close(ffd);

			int dfd = open("disk.dat", O_RDWR);
			lseek(dfd, file_capacity*(found+1), SEEK_SET);
			char * d_buffer = (char *)malloc(file_capacity*post_num);
			read(dfd, d_buffer, file_capacity*post_num);
			lseek(dfd, file_capacity*found, SEEK_SET);
			write(dfd, d_buffer, file_capacity*post_num);
			free(d_buffer);
			close(dfd);

			snprintf(message, 512, "%s deleted for user %s", argp->file_name, argp->user_name);
		}
	}
    result.out_msg.out_msg_len = strlen(message) + 1;
    result.out_msg.out_msg_val = strdup(message);
	return &result;
}

seek_output *
seek_position_1_svc(seek_input *argp, struct svc_req *rqstp){
	static seek_output result;
	init_disk();
	printf("(Seek)In server: username received: %s, fd received: %d, seek_pos received: %d\n", argp->user_name, argp->fd, argp->position);
	char message[512];

	bool found = false;
	file_item *item_ptr = nullptr;
	for(int i=0; i<open_table_ptr->items.size(); i++){
		item_ptr = &open_table_ptr->items[i];
		if(item_ptr->fd == argp->fd){
			found = true;
			break;
		}
	}

	result.success = 0;
	if(!found){
		snprintf(message, 512, "Seek: Invalid file descriptor");
	}else{
		if(argp->position >= 0 && argp->position < file_capacity){
			item_ptr->fptr = argp->position;
			snprintf(message, 512, "file pointer of '%s' now at %d", item_ptr->file_name, argp->position);
			result.success = 1;
			item_ptr->seek_flag = true;
		}else{
			snprintf(message, 512, "Seek: Invalid seek position");
		}
	}

	result.out_msg.out_msg_len = strlen(message) + 1;
	result.out_msg.out_msg_val = strdup(message);
	return &result;
}

read_output *
read_file_1_svc(read_input *argp, struct svc_req *rqstp){
	static read_output result;
	init_disk();
	printf("(Read)In server: username received: %s, fd received: %d, numbytes received: %d\n", argp->user_name, argp->fd, argp->numbytes);
	char message[512];

	result.success = 0;
	int sq_no = get_sqno_from_fdtable(argp->fd); // check if opened
	if(sq_no < 0){
		snprintf(message, 512, "Read: Invalid file descriptor");
	}else{
		file_item *item_ptr = nullptr;
		for(int i=0; i<open_table_ptr->items.size(); i++){
			item_ptr = &open_table_ptr->items[i];
			if(item_ptr->fd == argp->fd) break;
		}
		if(!item_ptr->seek_flag) item_ptr->fptr = 0;

		if(item_ptr->fptr + argp->numbytes >= file_capacity){
			snprintf(message, 512, "Read: Trying to read past the end of file");
		}else{
			int prefix = file_capacity*sq_no;
			int dfd = open("disk.dat", O_RDONLY);
			lseek(dfd, prefix + item_ptr->fptr, SEEK_SET);
			char * read_buffer = (char *)malloc(argp->numbytes + 1);
			read(dfd, read_buffer, argp->numbytes);
			close(dfd);
			result.buffer.buffer_len = strlen(read_buffer) + 1;
			result.buffer.buffer_val = strdup(read_buffer);
			result.success = 1;
			free(read_buffer);
			item_ptr->fptr += argp->numbytes;
			item_ptr->seek_flag = true;
		}
	}
	result.out_msg.out_msg_len = strlen(message) + 1;
	result.out_msg.out_msg_val = strdup(message);
	return &result;
}

write_output *
write_file_1_svc(write_input *argp, struct svc_req *rqstp){
	static write_output result;
	init_disk();
	printf("(Write)In server: username received: %s, fd received: %d, numbytes received: %d\n", argp->user_name, argp->fd, argp->numbytes);
	char message[512];

	result.success = 0;
	int sq_no = get_sqno_from_fdtable(argp->fd); // check if opened
	if(sq_no < 0){
		snprintf(message, 512, "Read: Invalid file descriptor");
	}else{
		file_item *item_ptr = nullptr;
		for(int i=0; i<open_table_ptr->items.size(); i++){
			item_ptr = &open_table_ptr->items[i];
			if(item_ptr->fd == argp->fd) break;
		}
		if(!item_ptr->seek_flag) item_ptr->fptr = 0;

		if(item_ptr->fptr + argp->numbytes > file_capacity){
			snprintf(message, 512, "Read: Trying to write past the end of file");
		}else{
			int prefix = file_capacity*sq_no;
			int dfd = open("disk.dat", O_RDWR);
			lseek(dfd, prefix + (item_ptr->fptr), SEEK_SET);
			write(dfd, argp->buffer.buffer_val, argp->numbytes);
			close(dfd);
			snprintf(message, 512, "%d characters written in %s", argp->numbytes, item_ptr->file_name);
			item_ptr->fptr += argp->numbytes;
			item_ptr->used = std::max(item_ptr->used, item_ptr->fptr);
			result.success = 1;
			item_ptr->seek_flag = true;
		}
	}
	result.out_msg.out_msg_len = strlen(message) + 1;
	result.out_msg.out_msg_val = strdup(message);
	return &result;
}